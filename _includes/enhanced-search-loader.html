<!--
  Enhanced Jekyll Search with Lunr.js
  Provides full-text search with highlighting similar to mdbook
-->

{% capture result_elem %}
  <article class="search-result-item px-1 px-sm-2 px-lg-4 px-xl-0">
    <header>
      <h2><a href="{url}" class="search-result-title">{title}</a></h2>
      <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">
        {categories}
        {tags}
      </div>
    </header>
    <div class="search-result-content">
      {content}
    </div>
  </article>
{% endcapture %}

{% capture not_found %}<p class="mt-5">{{ site.data.locales[include.lang].search.no_results }}</p>{% endcapture %}

<script src="https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    let searchIndex = null;
    let searchData = null;
    let searchResults = [];

    // Load search data and build index
    fetch('{{ '/assets/js/data/search.json' | relative_url }}')
      .then(response => response.json())
      .then(data => {
        searchData = data;
        searchIndex = lunr(function () {
          this.ref('id');
          this.field('title', { boost: 10 });
          this.field('content', { boost: 5 });
          this.field('categories', { boost: 3 });
          this.field('tags', { boost: 3 });
          
          // Add documents to index
          data.forEach(doc => {
            this.add(doc);
          });
        });
      })
      .catch(error => {
        console.error('Error loading search data:', error);
      });

    // Search function
    function performSearch(query) {
      if (!searchIndex || !searchData) return;
      
      const results = searchIndex.search(query);
      searchResults = results.map(result => {
        const doc = searchData.find(d => d.id === result.ref);
        return {
          ...doc,
          score: result.score,
          matchData: result.matchData
        };
      });
      
      displayResults(searchResults, query);
    }

    // Display search results with highlighting
    function displayResults(results, query) {
      const resultsContainer = document.getElementById('search-results');
      const resultWrapper = document.getElementById('search-result-wrapper');
      
      if (results.length === 0) {
        resultsContainer.innerHTML = '{{ not_found }}';
        resultWrapper.classList.remove('d-none');
        return;
      }

      let html = '';
      results.slice(0, 10).forEach(result => {
        // Find matching sections with context
        const matchingSnippets = findMatchingSnippets(result, query);
        
        // Build result HTML
        let resultHtml = '{{ result_elem | strip_newlines }}';
        
        // Replace placeholders with highlighting parameters
        const urlWithHighlight = `${result.url}?highlight=${encodeURIComponent(query)}`;
        resultHtml = resultHtml.replace('{url}', urlWithHighlight);
        resultHtml = resultHtml.replace('{title}', highlightText(result.title, query));
        resultHtml = resultHtml.replace('{content}', matchingSnippets);
        
        // Handle categories
        if (result.categories && result.categories.trim()) {
          resultHtml = resultHtml.replace('{categories}', 
            `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${result.categories}</div>`);
        } else {
          resultHtml = resultHtml.replace('{categories}', '');
        }
        
        // Handle tags
        if (result.tags && result.tags.trim()) {
          resultHtml = resultHtml.replace('{tags}', 
            `<div><i class="fa fa-tag fa-fw"></i>${result.tags}</div>`);
        } else {
          resultHtml = resultHtml.replace('{tags}', '');
        }
        
        html += resultHtml;
      });
      
      resultsContainer.innerHTML = html;
      resultWrapper.classList.remove('d-none');
    }

    // Find matching snippets with context around search terms
    function findMatchingSnippets(result, query) {
      if (!result.sections || result.sections.length === 0) {
        // Fallback to content-based search if no sections
        return createContentSnippet(result.content, query);
      }
      
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
      const matchingSections = result.sections.filter(section => {
        const text = section.text.toLowerCase();
        return queryWords.some(word => text.includes(word));
      });
      
      if (matchingSections.length === 0) {
        return createContentSnippet(result.content, query);
      }
      
      // Create snippets from matching sections
      let snippets = [];
      matchingSections.slice(0, 3).forEach(section => {
        const snippet = createSnippetFromSection(section, query);
        if (snippet) {
          snippets.push(snippet);
        }
      });
      
      return snippets.join('<br><br>');
    }
    
    // Create snippet from section content
    function createSnippetFromSection(section, query) {
      const text = section.text;
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
      
      // Find the position of the first match
      let bestMatch = null;
      let bestPosition = -1;
      
      queryWords.forEach(word => {
        const position = text.toLowerCase().indexOf(word.toLowerCase());
        if (position !== -1 && (bestPosition === -1 || position < bestPosition)) {
          bestPosition = position;
          bestMatch = word;
        }
      });
      
      if (bestPosition === -1) return null;
      
      // Create context around the match (3 lines before and after)
      const lines = text.split('\n');
      let contextStart = 0;
      let contextEnd = lines.length;
      
      // Find the line containing the match
      let currentPos = 0;
      let matchLine = 0;
      for (let i = 0; i < lines.length; i++) {
        const lineLength = lines[i].length + 1; // +1 for newline
        if (currentPos + lineLength > bestPosition) {
          matchLine = i;
          break;
        }
        currentPos += lineLength;
      }
      
      // Get 3 lines before and after the match
      contextStart = Math.max(0, matchLine - 3);
      contextEnd = Math.min(lines.length, matchLine + 4);
      
      const contextLines = lines.slice(contextStart, contextEnd);
      let snippet = contextLines.join('\n');
      
      // Truncate if too long (max 500 characters)
      if (snippet.length > 500) {
        const matchInSnippet = snippet.toLowerCase().indexOf(bestMatch.toLowerCase());
        const start = Math.max(0, matchInSnippet - 200);
        const end = Math.min(snippet.length, matchInSnippet + 300);
        snippet = '...' + snippet.substring(start, end) + '...';
      }
      
      // Highlight the search terms
      snippet = highlightText(snippet, query);
      
      return `<div class="search-snippet">${snippet}</div>`;
    }
    
    // Create snippet from full content (fallback)
    function createContentSnippet(content, query) {
      if (!content) return '';
      
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
      const text = content.toLowerCase();
      
      // Find the first occurrence of any query word
      let bestPosition = -1;
      let bestWord = '';
      
      queryWords.forEach(word => {
        const position = text.indexOf(word);
        if (position !== -1 && (bestPosition === -1 || position < bestPosition)) {
          bestPosition = position;
          bestWord = word;
        }
      });
      
      if (bestPosition === -1) {
        // No match found, return first 200 characters
        return `<div class="search-snippet">${content.substring(0, 200)}...</div>`;
      }
      
      // Create context around the match
      const start = Math.max(0, bestPosition - 200);
      const end = Math.min(content.length, bestPosition + 300);
      let snippet = content.substring(start, end);
      
      if (start > 0) snippet = '...' + snippet;
      if (end < content.length) snippet = snippet + '...';
      
      // Highlight the search terms
      snippet = highlightText(snippet, query);
      
      return `<div class="search-snippet">${snippet}</div>`;
    }

    // Highlight text with search terms
    function highlightText(text, query) {
      if (!text || !query) return text;
      
      const queryWords = query.split(/\s+/).filter(word => word.length > 2);
      let highlightedText = text;
      
      queryWords.forEach(word => {
        const regex = new RegExp(`(${escapeRegExp(word)})`, 'gi');
        highlightedText = highlightedText.replace(regex, '<mark class="search-highlight">$1</mark>');
      });
      
      return highlightedText;
    }

    // Escape special regex characters
    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Handle search input
    const searchInput = document.getElementById('search-input');
    let searchTimeout;

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.trim();
      
      clearTimeout(searchTimeout);
      
      if (query.length < 2) {
        document.getElementById('search-result-wrapper').classList.add('d-none');
        return;
      }
      
      searchTimeout = setTimeout(() => {
        performSearch(query);
      }, 300);
    });

    // Handle URL search parameters (like ?search=test)
    const urlParams = new URLSearchParams(window.location.search);
    const urlSearchQuery = urlParams.get('search');
    if (urlSearchQuery) {
      searchInput.value = urlSearchQuery;
      performSearch(urlSearchQuery);
    }

    // Handle highlight parameter (like ?highlight=test)
    const highlightQuery = urlParams.get('highlight');
    if (highlightQuery) {
      // Highlight text on the current page and scroll to it
      highlightTextOnPage(highlightQuery);
    }

    // Function to highlight text on the current page
    function highlightTextOnPage(query) {
      const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.parentNode.tagName !== 'SCRIPT' && node.parentNode.tagName !== 'STYLE') {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const text = textNode.textContent;
        const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
        if (regex.test(text)) {
          const highlightedHTML = text.replace(regex, '<mark class="search-highlight">$1</mark>');
          const wrapper = document.createElement('div');
          wrapper.innerHTML = highlightedHTML;
          
          while (wrapper.firstChild) {
            textNode.parentNode.insertBefore(wrapper.firstChild, textNode);
          }
          textNode.remove();
        }
      });

      // Scroll to the first highlighted element
      const highlightedElements = document.querySelectorAll('mark.search-highlight');
      if (highlightedElements.length > 0) {
        highlightedElements[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  });
</script>

<style>
  .search-highlight {
    background-color: #ffeb3b;
    color: #000;
    padding: 0.1em 0.2em;
    border-radius: 0.2em;
    font-weight: bold;
  }
  
  .search-result-item {
    margin-bottom: 1.5rem;
    padding: 1rem;
    border: 1px solid var(--main-border-color);
    border-radius: 0.5rem;
    background: var(--card-bg);
  }
  
  .search-result-title {
    color: var(--heading-color);
    text-decoration: none;
  }
  
  .search-result-title:hover {
    color: var(--link-color);
  }
  
  .search-result-content {
    margin-top: 0.5rem;
    line-height: 1.6;
  }
  
  .search-result-content mark {
    background-color: #ffeb3b;
    color: #000;
    padding: 0.1em 0.2em;
    border-radius: 0.2em;
  }
  
  .search-snippet {
    background: var(--card-bg);
    border: 1px solid var(--main-border-color);
    border-radius: 0.375rem;
    padding: 0.75rem;
    margin: 0.5rem 0;
    font-family: var(--font-family-monospace);
    font-size: 0.875rem;
    line-height: 1.5;
    white-space: pre-wrap;
    overflow: hidden;
    position: relative;
  }
  
  .search-snippet::before {
    content: "ðŸ“„";
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    opacity: 0.5;
    font-size: 0.75rem;
  }
  
  .search-snippet mark {
    background-color: #ffeb3b;
    color: #000;
    padding: 0.1em 0.2em;
    border-radius: 0.2em;
    font-weight: bold;
  }
</style>
